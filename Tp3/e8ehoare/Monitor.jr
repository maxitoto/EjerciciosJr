/* This JR file was generated by m2jr */
/* for the signal and wait signaling discipline */


// Monitor.m, line 1: import java.util.LinkedList;

import
java
.util
.LinkedList
;
// Monitor.m, line 2: _monitor Monitor{

class Monitor {
  sem m_mutex = 1;
  sem m_urgentq = 0;
  int m_n_urgentq = 0;
  String m_name;
  public Monitor(String n) {
    this.m_name = n;
  }
  private void m_next() {
      if (m_n_urgentq > 0) {
        m_n_urgentq--;
        V(m_urgentq);
      }
      else {
        V(m_mutex);
      }
  }

// Monitor.m, line 3:     _var static final int n = 10;

private static
final
int
n
=10;
// Monitor.m, line 4:     _var String[] bufferS = new String[n];

private String
[]bufferS
=new
String
[n
];
// Monitor.m, line 5: 


// Monitor.m, line 6:     _var int cantElement = 0;

private int
cantElement
=0;
// Monitor.m, line 7:     _var int frente = 0;

private int
frente
=0;
// Monitor.m, line 8:     _var int cola = 0;

private int
cola
=0;
// Monitor.m, line 9: 


// Monitor.m, line 10:     _condvar sevacie;


// Monitor.m, line 11:     _condvar sellene;

private m_condvar sevacie = new m_condvar("sevacie");

// Monitor.m, line 12: 


// Monitor.m, line 13:     _proc void producir(int id){

private m_condvar sellene = new m_condvar("sellene");
public
void
producir
(int
id
){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 14:         if(cantElement==n){

if
(cantElement
==n
){
// Monitor.m, line 15:             _wait(sevacie);

{  m_condvar m_cv = (sevacie );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
}
// Monitor.m, line 16:         }


// Monitor.m, line 17:         bufferS[frente] = "producido por "+id;

}bufferS
[frente
]="producido por "+id
;
// Monitor.m, line 18:         frente = (frente+1) % n;

frente
=(frente
+1)%n
;
// Monitor.m, line 19:         System.out.println("productor "+id+" produce en indx:"+frente);

System
.out
.println
("productor "+id
+" produce en indx:"+frente
);
// Monitor.m, line 20:         


// Monitor.m, line 21:         cantElement+=1;

cantElement
+=1;
// Monitor.m, line 22:         


// Monitor.m, line 23:         _signal(sellene);

{ if ((sellene ).m_signal()) {
  P(m_mutex);
}}

// Monitor.m, line 24: 


// Monitor.m, line 25:     }


// Monitor.m, line 26: 


// Monitor.m, line 27:     _proc void consumir(int id){

  m_next();
}
public
void
consumir
(int
id
){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 28:         if(cantElement==0){

if
(cantElement
==0){
// Monitor.m, line 29:             _wait(sellene);

{  m_condvar m_cv = (sellene );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
}
// Monitor.m, line 30:         }


// Monitor.m, line 31: 


// Monitor.m, line 32:         System.out.println("consumidor "+id+" consume "+bufferS[cola]+"["+cola+"]");

}System
.out
.println
("consumidor "+id
+" consume "+bufferS
[cola
]+"["+cola
+"]");
// Monitor.m, line 33:         cola = (cola+1) % n;

cola
=(cola
+1)%n
;
// Monitor.m, line 34: 


// Monitor.m, line 35:         cantElement-=1;

cantElement
-=1;
// Monitor.m, line 36: 


// Monitor.m, line 37:         _signal(sevacie);

{ if ((sevacie ).m_signal()) {
  P(m_mutex);
}}

// Monitor.m, line 38:     }


// Monitor.m, line 39: 


// Monitor.m, line 40: }
  m_next();
}
}
