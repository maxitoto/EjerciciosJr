/* This JR file was generated by m2jr */
/* for the signal and continue signaling discipline */


// Monitor.m, line 1: _monitor Monitor{

class Monitor {
  sem m_mutex = 1;
  sem m_urgentq = 0;
  int m_n_urgentq = 0;
  String m_name;
  public Monitor(String n) {
    this.m_name = n;
  }
  private void m_next() {
      if (m_n_urgentq > 0) {
        m_n_urgentq--;
        V(m_urgentq);
      }
      else {
        V(m_mutex);
      }
  }

// Monitor.m, line 2:     static final boolean[] CPUs = {true, true};

static
final
boolean
[]CPUs
={true
,true
};
// Monitor.m, line 3:     _var int cpuDisponible = 2;

private int
cpuDisponible
=2;
// Monitor.m, line 4:     _condvar hayaCPUdisponible;


// Monitor.m, line 5:     _var int contAsignaciones = 0;

private m_condvar hayaCPUdisponible = new m_condvar("hayaCPUdisponible");
private int
contAsignaciones
=0;
// Monitor.m, line 6:     _var int soyElUltimo = 0;

private int
soyElUltimo
=0;
// Monitor.m, line 7: 


// Monitor.m, line 8:     _proc int adquirirCPU(int Pid){

public
int
adquirirCPU
(int
Pid
){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 9:         soyElUltimo++;

soyElUltimo
++;
// Monitor.m, line 10:         while(cpuDisponible==0){

while
(cpuDisponible
==0){
// Monitor.m, line 11:             System.out.println("no hay recursos disponibles para el proceso "+Pid);

System
.out
.println
("no hay recursos disponibles para el proceso "+Pid
);
// Monitor.m, line 12:             _wait(hayaCPUdisponible);

{  m_condvar m_cv = (hayaCPUdisponible );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
  P(m_mutex);
}
// Monitor.m, line 13:         }


// Monitor.m, line 14: 


// Monitor.m, line 15:         cpuDisponible--;

}cpuDisponible
--;
// Monitor.m, line 16: 


// Monitor.m, line 17:         if(CPUs[0]){

if
(CPUs
[0]){
// Monitor.m, line 18:             CPUs[0]=false;

CPUs
[0]=false
;
// Monitor.m, line 19:             contAsignaciones++;

contAsignaciones
++;
// Monitor.m, line 20:             _return 0;

{ if (true) {
  m_next();
  return 
0
// Monitor.m, line 21:         }else{

;
}}
}else
{
// Monitor.m, line 22:             CPUs[1]=false;

CPUs
[1]=false
;
// Monitor.m, line 23:             contAsignaciones++;

contAsignaciones
++;
// Monitor.m, line 24:             _return 1;

{ if (true) {
  m_next();
  return 
1
// Monitor.m, line 25:         }

;
}}

// Monitor.m, line 26:     }

}
// Monitor.m, line 27: 


// Monitor.m, line 28:     _proc void liberarCpu(int cpu){

  m_next();
throw new RuntimeException("reached end of non-void _proc (Monitor.m, line 28) without executing a return");
}
public
void
liberarCpu
(int
cpu
){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 29:             cpuDisponible++;

cpuDisponible
++;
// Monitor.m, line 30:             soyElUltimo--;

soyElUltimo
--;
// Monitor.m, line 31:             CPUs[cpu]=true;

CPUs
[cpu
]=true
;
// Monitor.m, line 32:             _signal(hayaCPUdisponible);

(hayaCPUdisponible ).m_signal();

// Monitor.m, line 33: 


// Monitor.m, line 34:             if(soyElUltimo==0){

if
(soyElUltimo
==0){
// Monitor.m, line 35:             System.out.println("Asignaciones Totales: "+contAsignaciones);

System
.out
.println
("Asignaciones Totales: "+contAsignaciones
);
// Monitor.m, line 36:         }


// Monitor.m, line 37:     }

}
// Monitor.m, line 38: }
  m_next();
}
}
