/* This JR file was generated by m2jr */
/* for the signal and continue signaling discipline */


// Monitor.m, line 1: _monitor Monitor{

class Monitor {
  sem m_mutex = 1;
  sem m_urgentq = 0;
  int m_n_urgentq = 0;
  String m_name;
  public Monitor(String n) {
    this.m_name = n;
  }
  private void m_next() {
      if (m_n_urgentq > 0) {
        m_n_urgentq--;
        V(m_urgentq);
      }
      else {
        V(m_mutex);
      }
  }

// Monitor.m, line 2:     static String[] ingredientes = {"Tabaco","Papel","Cerillas"};

static
String
[]ingredientes
={"Tabaco","Papel","Cerillas"};
// Monitor.m, line 3:     static String[] mesa = new String[2];

static
String
[]mesa
=new
String
[2];
// Monitor.m, line 4: 


// Monitor.m, line 5: 


// Monitor.m, line 6:     _condvar pongaIngredientes; _var boolean noPedirIngredientes = true;

private m_condvar pongaIngredientes = new m_condvar("pongaIngredientes");
private boolean
noPedirIngredientes
=true
;
// Monitor.m, line 7:     _condvar ponerIngredientes; _var boolean nadiequiereIng = false;

private m_condvar ponerIngredientes = new m_condvar("ponerIngredientes");
private boolean
nadiequiereIng
=false
;
// Monitor.m, line 8:  


// Monitor.m, line 9:     _proc void colocarIngredientes(){

public
void
colocarIngredientes
(){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 10:         while(nadiequiereIng){

while
(nadiequiereIng
){
// Monitor.m, line 11:             _wait(ponerIngredientes);

{  m_condvar m_cv = (ponerIngredientes );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
  P(m_mutex);
}
// Monitor.m, line 12:         }


// Monitor.m, line 13:         nadiequiereIng = true;

}nadiequiereIng
=true
;
// Monitor.m, line 14: 


// Monitor.m, line 15:         int ingredienteYaexistente = (int) (Math.random() * 3);

int
ingredienteYaexistente
=(int
)(Math
.random
()*3);
// Monitor.m, line 16: 


// Monitor.m, line 17:         int j = 0;

int
j
=0;
// Monitor.m, line 18: 


// Monitor.m, line 19:         for(int i = 0; i<3; i++){

for
(int
i
=0;i
<3;i
++){
// Monitor.m, line 20:             if(!(i==ingredienteYaexistente)){

if
(!(i
==ingredienteYaexistente
)){
// Monitor.m, line 21:                 mesa[j] = ingredientes[i];

mesa
[j
]=ingredientes
[i
];
// Monitor.m, line 22:                 j++;

j
++;
// Monitor.m, line 23:             }


// Monitor.m, line 24:         }

}
// Monitor.m, line 25: 


// Monitor.m, line 26:         System.out.println("Se coloco en la mesa "+mesa[0]+" y "+mesa[1]);

}System
.out
.println
("Se coloco en la mesa "+mesa
[0]+" y "+mesa
[1]);
// Monitor.m, line 27: 


// Monitor.m, line 28:         noPedirIngredientes = false;

noPedirIngredientes
=false
;
// Monitor.m, line 29:         _signal(pongaIngredientes);

(pongaIngredientes ).m_signal();

// Monitor.m, line 30: 


// Monitor.m, line 31:     }


// Monitor.m, line 32: 


// Monitor.m, line 33:     _proc boolean comprobarMesa(int id){

  m_next();
}
public
boolean
comprobarMesa
(int
id
){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 34:         while(noPedirIngredientes){

while
(noPedirIngredientes
){
// Monitor.m, line 35:             _wait(pongaIngredientes);

{  m_condvar m_cv = (pongaIngredientes );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
  P(m_mutex);
}
// Monitor.m, line 36:         }


// Monitor.m, line 37:         


// Monitor.m, line 38:         noPedirIngredientes = true;

}noPedirIngredientes
=true
;
// Monitor.m, line 39: 


// Monitor.m, line 40:         if(id == 1 & mesa[0]==ingredientes[0] & mesa[1]==ingredientes[1]){_return true;}

if
(id
==1&mesa
[0]==ingredientes
[0]&mesa
[1]==ingredientes
[1]){{ if (true) {
  m_next();
  return 
true
;
}}

// Monitor.m, line 41:         else{

}else
{
// Monitor.m, line 42:             if(id == 2 & mesa[0]==ingredientes[0] & mesa[1]==ingredientes[2]){_return true;}

if
(id
==2&mesa
[0]==ingredientes
[0]&mesa
[1]==ingredientes
[2]){{ if (true) {
  m_next();
  return 
true
;
}}

// Monitor.m, line 43:                 else{

}else
{
// Monitor.m, line 44:                     if(id == 3 & mesa[0]==ingredientes[1] & mesa[1]==ingredientes[2]){_return true;}}}

if
(id
==3&mesa
[0]==ingredientes
[1]&mesa
[1]==ingredientes
[2]){{ if (true) {
  m_next();
  return 
true
;
}}
}}
// Monitor.m, line 45:         


// Monitor.m, line 46:         noPedirIngredientes = false;

}noPedirIngredientes
=false
;
// Monitor.m, line 47:         _signal(pongaIngredientes);

(pongaIngredientes ).m_signal();

// Monitor.m, line 48:         _return false;            

{ if (true) {
  m_next();
  return 
false

// Monitor.m, line 49:     }

;
}}

// Monitor.m, line 50: 


// Monitor.m, line 51:     _proc void fumar(int id){

  m_next();
throw new RuntimeException("reached end of non-void _proc (Monitor.m, line 51) without executing a return");
}
public
void
fumar
(int
id
){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 52:         System.out.println("El fumador "+id+" fuma el cigarrillo");

System
.out
.println
("El fumador "+id
+" fuma el cigarrillo");
// Monitor.m, line 53:         nadiequiereIng = false;

nadiequiereIng
=false
;
// Monitor.m, line 54:         _signal(ponerIngredientes);

(ponerIngredientes ).m_signal();

// Monitor.m, line 55:     }


// Monitor.m, line 56: }
  m_next();
}
}
