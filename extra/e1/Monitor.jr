/* This JR file was generated by m2jr */
/* for the signal and continue signaling discipline */


// Monitor.m, line 1: _monitor Monitor {

class Monitor {
  sem m_mutex = 1;
  sem m_urgentq = 0;
  int m_n_urgentq = 0;
  String m_name;
  public Monitor(String n) {
    this.m_name = n;
  }
  private void m_next() {
      if (m_n_urgentq > 0) {
        m_n_urgentq--;
        V(m_urgentq);
      }
      else {
        V(m_mutex);
      }
  }

// Monitor.m, line 2: 


// Monitor.m, line 3:     _var int conteoNS = 0; // Contador de autos cruzando de Norte a Sur

private int
conteoNS
=0;
// Monitor.m, line 4:     _var boolean NopuedoCruzarNS = false;

private boolean
NopuedoCruzarNS
=false
;
// Monitor.m, line 5:     _condvar queSeLibereNS;


// Monitor.m, line 6:     _var int autosEsperandoNS = 0;

private m_condvar queSeLibereNS = new m_condvar("queSeLibereNS");
private int
autosEsperandoNS
=0;
// Monitor.m, line 7: 


// Monitor.m, line 8:     _var int conteoSN = 0; // Contador de autos cruzando de Sur a Norte

private int
conteoSN
=0;
// Monitor.m, line 9:     _var boolean NopuedoCruzarSN = false;

private boolean
NopuedoCruzarSN
=false
;
// Monitor.m, line 10:     _condvar queSeLibereSN;


// Monitor.m, line 11:     _var int autosEsperandoSN = 0;

private m_condvar queSeLibereSN = new m_condvar("queSeLibereSN");
private int
autosEsperandoSN
=0;
// Monitor.m, line 12: 


// Monitor.m, line 13:     _proc void cruzarNS(){

public
void
cruzarNS
(){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 14:         // Si no se puede cruzar, esperar


// Monitor.m, line 15:         while(NopuedoCruzarNS || conteoNS==5){

while
(NopuedoCruzarNS
||conteoNS
==5){
// Monitor.m, line 16:             autosEsperandoNS++;

autosEsperandoNS
++;
// Monitor.m, line 17:             _wait(queSeLibereNS);

{  m_condvar m_cv = (queSeLibereNS );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
  P(m_mutex);
}
// Monitor.m, line 18:             autosEsperandoNS--;

autosEsperandoNS
--;
// Monitor.m, line 19:         }


// Monitor.m, line 20: 


// Monitor.m, line 21:         // Permitir cruce de Norte a Sur


// Monitor.m, line 22:         NopuedoCruzarSN = true; // Bloquear la dirección Sur a Norte

}NopuedoCruzarSN
=true
;
// Monitor.m, line 23:         conteoNS++;

conteoNS
++;
// Monitor.m, line 24:     }


// Monitor.m, line 25: 


// Monitor.m, line 26:     _proc void terminoNS(){

  m_next();
}
public
void
terminoNS
(){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 27:         // Si hay autos esperando en la dirección contraria y se alcanzó el límite de N autos


// Monitor.m, line 28:         if(autosEsperandoSN != 0 && conteoNS == 5){

if
(autosEsperandoSN
!=0&&conteoNS
==5){
// Monitor.m, line 29:             conteoNS = 0;

conteoNS
=0;
// Monitor.m, line 30:             NopuedoCruzarNS = true;  // Bloquear el cruce de Sur a Norte

NopuedoCruzarNS
=true
;
// Monitor.m, line 31:             NopuedoCruzarSN = false; // Permitir el cruce de Norte a Sur

NopuedoCruzarSN
=false
;
// Monitor.m, line 32:             for(int j = 0; j < autosEsperandoSN; j++){

for
(int
j
=0;j
<autosEsperandoSN
;j
++){
// Monitor.m, line 33:                 _signal(queSeLibereSN); // Despertar a los autos esperando en el Norte

(queSeLibereSN ).m_signal();

// Monitor.m, line 34:             }


// Monitor.m, line 35:         }else{

}}else
{
// Monitor.m, line 36:             if(autosEsperandoSN == 0){

if
(autosEsperandoSN
==0){
// Monitor.m, line 37:                 conteoNS=6;

conteoNS
=6;
// Monitor.m, line 38:             }


// Monitor.m, line 39:         }

}
// Monitor.m, line 40:     }

}
// Monitor.m, line 41: 


// Monitor.m, line 42:     _proc void cruzarSN(){

  m_next();
}
public
void
cruzarSN
(){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 43:         // Si no se puede cruzar, esperar


// Monitor.m, line 44:         while(NopuedoCruzarSN || conteoSN==5){

while
(NopuedoCruzarSN
||conteoSN
==5){
// Monitor.m, line 45:             autosEsperandoSN++;

autosEsperandoSN
++;
// Monitor.m, line 46:             _wait(queSeLibereSN);

{  m_condvar m_cv = (queSeLibereSN );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
  P(m_mutex);
}
// Monitor.m, line 47:             autosEsperandoSN--;

autosEsperandoSN
--;
// Monitor.m, line 48:         }


// Monitor.m, line 49: 


// Monitor.m, line 50:         // Permitir cruce de Sur a Norte


// Monitor.m, line 51:         NopuedoCruzarNS = true; // Bloquear la dirección Norte a Sur

}NopuedoCruzarNS
=true
;
// Monitor.m, line 52:         conteoSN++;

conteoSN
++;
// Monitor.m, line 53:     }


// Monitor.m, line 54: 


// Monitor.m, line 55:     _proc void terminoSN(){

  m_next();
}
public
void
terminoSN
(){
    op void m_return_from_wait();
    P(m_mutex);

// Monitor.m, line 56:         // Si hay autos esperando en la dirección contraria y se alcanzó el límite de N autos


// Monitor.m, line 57:         if(autosEsperandoNS != 0 && conteoSN == 5){

if
(autosEsperandoNS
!=0&&conteoSN
==5){
// Monitor.m, line 58:             conteoSN = 0;

conteoSN
=0;
// Monitor.m, line 59:             NopuedoCruzarSN = true;  // Bloquear el cruce de Sur a Norte

NopuedoCruzarSN
=true
;
// Monitor.m, line 60:             NopuedoCruzarNS = false; // Permitir el cruce de Norte a Sur

NopuedoCruzarNS
=false
;
// Monitor.m, line 61:             for(int j = 0; j < autosEsperandoNS; j++){

for
(int
j
=0;j
<autosEsperandoNS
;j
++){
// Monitor.m, line 62:                 _signal(queSeLibereNS); // Despertar a los autos esperando en el Norte

(queSeLibereNS ).m_signal();

// Monitor.m, line 63:             }


// Monitor.m, line 64:         }else{

}}else
{
// Monitor.m, line 65:             if(autosEsperandoNS == 0){

if
(autosEsperandoNS
==0){
// Monitor.m, line 66:                 conteoSN=6;

conteoSN
=6;
// Monitor.m, line 67:             }


// Monitor.m, line 68:         }

}
// Monitor.m, line 69:     }

}
// Monitor.m, line 70: }

  m_next();
}
}
